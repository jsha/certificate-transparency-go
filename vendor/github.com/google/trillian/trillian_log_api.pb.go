// Code generated by protoc-gen-go. DO NOT EDIT.
// source: trillian_log_api.proto

/*
Package trillian is a generated protocol buffer package.

It is generated from these files:
	trillian_log_api.proto
	trillian_map_api.proto
	trillian_admin_api.proto
	trillian.proto

It has these top-level messages:
	ChargeTo
	QueueLeafRequest
	QueueLeafResponse
	AddSequencedLeafRequest
	AddSequencedLeafResponse
	GetInclusionProofRequest
	GetInclusionProofResponse
	GetInclusionProofByHashRequest
	GetInclusionProofByHashResponse
	GetConsistencyProofRequest
	GetConsistencyProofResponse
	GetLatestSignedLogRootRequest
	GetLatestSignedLogRootResponse
	GetSequencedLeafCountRequest
	GetSequencedLeafCountResponse
	GetEntryAndProofRequest
	GetEntryAndProofResponse
	InitLogRequest
	InitLogResponse
	QueueLeavesRequest
	QueueLeavesResponse
	AddSequencedLeavesRequest
	AddSequencedLeavesResponse
	GetLeavesByIndexRequest
	GetLeavesByIndexResponse
	GetLeavesByRangeRequest
	GetLeavesByRangeResponse
	GetLeavesByHashRequest
	GetLeavesByHashResponse
	QueuedLogLeaf
	LogLeaf
	Proof
	MapLeaf
	MapLeafInclusion
	GetMapLeavesRequest
	GetMapLeavesByRevisionRequest
	GetMapLeavesResponse
	SetMapLeavesRequest
	SetMapLeavesResponse
	GetSignedMapRootRequest
	GetSignedMapRootByRevisionRequest
	GetSignedMapRootResponse
	InitMapRequest
	InitMapResponse
	ListTreesRequest
	ListTreesResponse
	GetTreeRequest
	CreateTreeRequest
	UpdateTreeRequest
	DeleteTreeRequest
	UndeleteTreeRequest
	Tree
	SignedEntryTimestamp
	SignedLogRoot
	SignedMapRoot
*/
package trillian

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"
import google_rpc "google.golang.org/genproto/googleapis/rpc/status"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ChargeTo describes the user(s) associated with the request whose quota should
// be checked and charged.
type ChargeTo struct {
	// user is a list of personality-defined strings.
	// Trillian will treat them as /User/%{user}/... keys when checking and
	// charging quota.
	// If one or more of the specified users has insufficient quota, the
	// request will be denied.
	//
	// As an example, a Certificate Transparency frontend might set the following
	// user strings when sending a QueueLeaves request to the Trillian log:
	//   - The requesting IP address.
	//     This would limit the number of requests per IP.
	//   - The "intermediate-<hash>" for each of the intermediate certificates in
	//     the submitted chain.
	//     This would have the effect of limiting the rate of submissions under
	//     a given intermediate/root.
	User []string `protobuf:"bytes,1,rep,name=user" json:"user,omitempty"`
}

func (m *ChargeTo) Reset()                    { *m = ChargeTo{} }
func (m *ChargeTo) String() string            { return proto.CompactTextString(m) }
func (*ChargeTo) ProtoMessage()               {}
func (*ChargeTo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ChargeTo) GetUser() []string {
	if m != nil {
		return m.User
	}
	return nil
}

type QueueLeafRequest struct {
	LogId    int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaf     *LogLeaf  `protobuf:"bytes,2,opt,name=leaf" json:"leaf,omitempty"`
	ChargeTo *ChargeTo `protobuf:"bytes,3,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *QueueLeafRequest) Reset()                    { *m = QueueLeafRequest{} }
func (m *QueueLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueLeafRequest) ProtoMessage()               {}
func (*QueueLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *QueueLeafRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeafRequest) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *QueueLeafRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type QueueLeafResponse struct {
	QueuedLeaf *QueuedLogLeaf `protobuf:"bytes,2,opt,name=queued_leaf,json=queuedLeaf" json:"queued_leaf,omitempty"`
}

func (m *QueueLeafResponse) Reset()                    { *m = QueueLeafResponse{} }
func (m *QueueLeafResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueLeafResponse) ProtoMessage()               {}
func (*QueueLeafResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *QueueLeafResponse) GetQueuedLeaf() *QueuedLogLeaf {
	if m != nil {
		return m.QueuedLeaf
	}
	return nil
}

type AddSequencedLeafRequest struct {
	LogId    int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaf     *LogLeaf  `protobuf:"bytes,2,opt,name=leaf" json:"leaf,omitempty"`
	ChargeTo *ChargeTo `protobuf:"bytes,3,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *AddSequencedLeafRequest) Reset()                    { *m = AddSequencedLeafRequest{} }
func (m *AddSequencedLeafRequest) String() string            { return proto.CompactTextString(m) }
func (*AddSequencedLeafRequest) ProtoMessage()               {}
func (*AddSequencedLeafRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AddSequencedLeafRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *AddSequencedLeafRequest) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *AddSequencedLeafRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type AddSequencedLeafResponse struct {
	Result *QueuedLogLeaf `protobuf:"bytes,2,opt,name=result" json:"result,omitempty"`
}

func (m *AddSequencedLeafResponse) Reset()                    { *m = AddSequencedLeafResponse{} }
func (m *AddSequencedLeafResponse) String() string            { return proto.CompactTextString(m) }
func (*AddSequencedLeafResponse) ProtoMessage()               {}
func (*AddSequencedLeafResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *AddSequencedLeafResponse) GetResult() *QueuedLogLeaf {
	if m != nil {
		return m.Result
	}
	return nil
}

type GetInclusionProofRequest struct {
	LogId     int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex int64     `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	TreeSize  int64     `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	ChargeTo  *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetInclusionProofRequest) Reset()                    { *m = GetInclusionProofRequest{} }
func (m *GetInclusionProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofRequest) ProtoMessage()               {}
func (*GetInclusionProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetInclusionProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetInclusionProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetInclusionProofRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetInclusionProofResponse struct {
	Proof         *Proof         `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetInclusionProofResponse) Reset()                    { *m = GetInclusionProofResponse{} }
func (m *GetInclusionProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofResponse) ProtoMessage()               {}
func (*GetInclusionProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetInclusionProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetInclusionProofResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetInclusionProofByHashRequest struct {
	LogId           int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafHash        []byte    `protobuf:"bytes,2,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	TreeSize        int64     `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	OrderBySequence bool      `protobuf:"varint,4,opt,name=order_by_sequence,json=orderBySequence" json:"order_by_sequence,omitempty"`
	ChargeTo        *ChargeTo `protobuf:"bytes,5,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetInclusionProofByHashRequest) Reset()                    { *m = GetInclusionProofByHashRequest{} }
func (m *GetInclusionProofByHashRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashRequest) ProtoMessage()               {}
func (*GetInclusionProofByHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetInclusionProofByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetInclusionProofByHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetInclusionProofByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

func (m *GetInclusionProofByHashRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetInclusionProofByHashResponse struct {
	// Logs can potentially contain leaves with duplicate hashes so it's possible
	// for this to return multiple proofs.
	// TODO(gbelvin) only return one proof.
	Proof         []*Proof       `protobuf:"bytes,2,rep,name=proof" json:"proof,omitempty"`
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetInclusionProofByHashResponse) Reset()                    { *m = GetInclusionProofByHashResponse{} }
func (m *GetInclusionProofByHashResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInclusionProofByHashResponse) ProtoMessage()               {}
func (*GetInclusionProofByHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GetInclusionProofByHashResponse) GetProof() []*Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetInclusionProofByHashResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetConsistencyProofRequest struct {
	LogId          int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	FirstTreeSize  int64     `protobuf:"varint,2,opt,name=first_tree_size,json=firstTreeSize" json:"first_tree_size,omitempty"`
	SecondTreeSize int64     `protobuf:"varint,3,opt,name=second_tree_size,json=secondTreeSize" json:"second_tree_size,omitempty"`
	ChargeTo       *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetConsistencyProofRequest) Reset()                    { *m = GetConsistencyProofRequest{} }
func (m *GetConsistencyProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetConsistencyProofRequest) ProtoMessage()               {}
func (*GetConsistencyProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetConsistencyProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetFirstTreeSize() int64 {
	if m != nil {
		return m.FirstTreeSize
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetSecondTreeSize() int64 {
	if m != nil {
		return m.SecondTreeSize
	}
	return 0
}

func (m *GetConsistencyProofRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetConsistencyProofResponse struct {
	Proof         *Proof         `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetConsistencyProofResponse) Reset()                    { *m = GetConsistencyProofResponse{} }
func (m *GetConsistencyProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetConsistencyProofResponse) ProtoMessage()               {}
func (*GetConsistencyProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetConsistencyProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetConsistencyProofResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetLatestSignedLogRootRequest struct {
	LogId    int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	ChargeTo *ChargeTo `protobuf:"bytes,2,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetLatestSignedLogRootRequest) Reset()                    { *m = GetLatestSignedLogRootRequest{} }
func (m *GetLatestSignedLogRootRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootRequest) ProtoMessage()               {}
func (*GetLatestSignedLogRootRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetLatestSignedLogRootRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLatestSignedLogRootRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetLatestSignedLogRootResponse struct {
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,2,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetLatestSignedLogRootResponse) Reset()                    { *m = GetLatestSignedLogRootResponse{} }
func (m *GetLatestSignedLogRootResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLatestSignedLogRootResponse) ProtoMessage()               {}
func (*GetLatestSignedLogRootResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetLatestSignedLogRootResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetSequencedLeafCountRequest struct {
	LogId    int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	ChargeTo *ChargeTo `protobuf:"bytes,2,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetSequencedLeafCountRequest) Reset()                    { *m = GetSequencedLeafCountRequest{} }
func (m *GetSequencedLeafCountRequest) String() string            { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountRequest) ProtoMessage()               {}
func (*GetSequencedLeafCountRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetSequencedLeafCountRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetSequencedLeafCountRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetSequencedLeafCountResponse struct {
	LeafCount int64 `protobuf:"varint,2,opt,name=leaf_count,json=leafCount" json:"leaf_count,omitempty"`
}

func (m *GetSequencedLeafCountResponse) Reset()                    { *m = GetSequencedLeafCountResponse{} }
func (m *GetSequencedLeafCountResponse) String() string            { return proto.CompactTextString(m) }
func (*GetSequencedLeafCountResponse) ProtoMessage()               {}
func (*GetSequencedLeafCountResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetSequencedLeafCountResponse) GetLeafCount() int64 {
	if m != nil {
		return m.LeafCount
	}
	return 0
}

type GetEntryAndProofRequest struct {
	LogId     int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex int64     `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	TreeSize  int64     `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	ChargeTo  *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetEntryAndProofRequest) Reset()                    { *m = GetEntryAndProofRequest{} }
func (m *GetEntryAndProofRequest) String() string            { return proto.CompactTextString(m) }
func (*GetEntryAndProofRequest) ProtoMessage()               {}
func (*GetEntryAndProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetEntryAndProofRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *GetEntryAndProofRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetEntryAndProofResponse struct {
	Proof         *Proof         `protobuf:"bytes,2,opt,name=proof" json:"proof,omitempty"`
	Leaf          *LogLeaf       `protobuf:"bytes,3,opt,name=leaf" json:"leaf,omitempty"`
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,4,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetEntryAndProofResponse) Reset()                    { *m = GetEntryAndProofResponse{} }
func (m *GetEntryAndProofResponse) String() string            { return proto.CompactTextString(m) }
func (*GetEntryAndProofResponse) ProtoMessage()               {}
func (*GetEntryAndProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetEntryAndProofResponse) GetProof() *Proof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *GetEntryAndProofResponse) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *GetEntryAndProofResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type InitLogRequest struct {
	LogId    int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	ChargeTo *ChargeTo `protobuf:"bytes,2,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *InitLogRequest) Reset()                    { *m = InitLogRequest{} }
func (m *InitLogRequest) String() string            { return proto.CompactTextString(m) }
func (*InitLogRequest) ProtoMessage()               {}
func (*InitLogRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *InitLogRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *InitLogRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type InitLogResponse struct {
	Created *SignedLogRoot `protobuf:"bytes,1,opt,name=created" json:"created,omitempty"`
}

func (m *InitLogResponse) Reset()                    { *m = InitLogResponse{} }
func (m *InitLogResponse) String() string            { return proto.CompactTextString(m) }
func (*InitLogResponse) ProtoMessage()               {}
func (*InitLogResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *InitLogResponse) GetCreated() *SignedLogRoot {
	if m != nil {
		return m.Created
	}
	return nil
}

type QueueLeavesRequest struct {
	LogId    int64      `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaves   []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
	ChargeTo *ChargeTo  `protobuf:"bytes,3,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *QueueLeavesRequest) Reset()                    { *m = QueueLeavesRequest{} }
func (m *QueueLeavesRequest) String() string            { return proto.CompactTextString(m) }
func (*QueueLeavesRequest) ProtoMessage()               {}
func (*QueueLeavesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *QueueLeavesRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *QueueLeavesRequest) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *QueueLeavesRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type QueueLeavesResponse struct {
	// Same number and order as in the corresponding request.
	QueuedLeaves []*QueuedLogLeaf `protobuf:"bytes,2,rep,name=queued_leaves,json=queuedLeaves" json:"queued_leaves,omitempty"`
}

func (m *QueueLeavesResponse) Reset()                    { *m = QueueLeavesResponse{} }
func (m *QueueLeavesResponse) String() string            { return proto.CompactTextString(m) }
func (*QueueLeavesResponse) ProtoMessage()               {}
func (*QueueLeavesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *QueueLeavesResponse) GetQueuedLeaves() []*QueuedLogLeaf {
	if m != nil {
		return m.QueuedLeaves
	}
	return nil
}

type AddSequencedLeavesRequest struct {
	LogId    int64      `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	Leaves   []*LogLeaf `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
	ChargeTo *ChargeTo  `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *AddSequencedLeavesRequest) Reset()                    { *m = AddSequencedLeavesRequest{} }
func (m *AddSequencedLeavesRequest) String() string            { return proto.CompactTextString(m) }
func (*AddSequencedLeavesRequest) ProtoMessage()               {}
func (*AddSequencedLeavesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *AddSequencedLeavesRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *AddSequencedLeavesRequest) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *AddSequencedLeavesRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type AddSequencedLeavesResponse struct {
	// Same number and order as in the corresponding request.
	Results []*QueuedLogLeaf `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
}

func (m *AddSequencedLeavesResponse) Reset()                    { *m = AddSequencedLeavesResponse{} }
func (m *AddSequencedLeavesResponse) String() string            { return proto.CompactTextString(m) }
func (*AddSequencedLeavesResponse) ProtoMessage()               {}
func (*AddSequencedLeavesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *AddSequencedLeavesResponse) GetResults() []*QueuedLogLeaf {
	if m != nil {
		return m.Results
	}
	return nil
}

type GetLeavesByIndexRequest struct {
	LogId     int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafIndex []int64   `protobuf:"varint,2,rep,packed,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	ChargeTo  *ChargeTo `protobuf:"bytes,5,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetLeavesByIndexRequest) Reset()                    { *m = GetLeavesByIndexRequest{} }
func (m *GetLeavesByIndexRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByIndexRequest) ProtoMessage()               {}
func (*GetLeavesByIndexRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *GetLeavesByIndexRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByIndexRequest) GetLeafIndex() []int64 {
	if m != nil {
		return m.LeafIndex
	}
	return nil
}

func (m *GetLeavesByIndexRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetLeavesByIndexResponse struct {
	// TODO(gbelvin) reply with error codes. Reuse QueuedLogLeaf?
	Leaves        []*LogLeaf     `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetLeavesByIndexResponse) Reset()                    { *m = GetLeavesByIndexResponse{} }
func (m *GetLeavesByIndexResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByIndexResponse) ProtoMessage()               {}
func (*GetLeavesByIndexResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *GetLeavesByIndexResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *GetLeavesByIndexResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetLeavesByRangeRequest struct {
	LogId      int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	StartIndex int64     `protobuf:"varint,2,opt,name=start_index,json=startIndex" json:"start_index,omitempty"`
	Count      int64     `protobuf:"varint,3,opt,name=count" json:"count,omitempty"`
	ChargeTo   *ChargeTo `protobuf:"bytes,4,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetLeavesByRangeRequest) Reset()                    { *m = GetLeavesByRangeRequest{} }
func (m *GetLeavesByRangeRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByRangeRequest) ProtoMessage()               {}
func (*GetLeavesByRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GetLeavesByRangeRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByRangeRequest) GetStartIndex() int64 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

func (m *GetLeavesByRangeRequest) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetLeavesByRangeRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetLeavesByRangeResponse struct {
	// Returned log leaves starting from the `start_index` of the request, in
	// order. There may be fewer than `request.count` leaves returned, if the
	// requested range extended beyond the size of the tree or if the server opted
	// to return fewer leaves than requested.
	Leaves        []*LogLeaf     `protobuf:"bytes,1,rep,name=leaves" json:"leaves,omitempty"`
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,2,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetLeavesByRangeResponse) Reset()                    { *m = GetLeavesByRangeResponse{} }
func (m *GetLeavesByRangeResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByRangeResponse) ProtoMessage()               {}
func (*GetLeavesByRangeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *GetLeavesByRangeResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *GetLeavesByRangeResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

type GetLeavesByHashRequest struct {
	LogId           int64     `protobuf:"varint,1,opt,name=log_id,json=logId" json:"log_id,omitempty"`
	LeafHash        [][]byte  `protobuf:"bytes,2,rep,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
	OrderBySequence bool      `protobuf:"varint,3,opt,name=order_by_sequence,json=orderBySequence" json:"order_by_sequence,omitempty"`
	ChargeTo        *ChargeTo `protobuf:"bytes,5,opt,name=charge_to,json=chargeTo" json:"charge_to,omitempty"`
}

func (m *GetLeavesByHashRequest) Reset()                    { *m = GetLeavesByHashRequest{} }
func (m *GetLeavesByHashRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByHashRequest) ProtoMessage()               {}
func (*GetLeavesByHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *GetLeavesByHashRequest) GetLogId() int64 {
	if m != nil {
		return m.LogId
	}
	return 0
}

func (m *GetLeavesByHashRequest) GetLeafHash() [][]byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

func (m *GetLeavesByHashRequest) GetOrderBySequence() bool {
	if m != nil {
		return m.OrderBySequence
	}
	return false
}

func (m *GetLeavesByHashRequest) GetChargeTo() *ChargeTo {
	if m != nil {
		return m.ChargeTo
	}
	return nil
}

type GetLeavesByHashResponse struct {
	// TODO(gbelvin) reply with error codes. Reuse QueuedLogLeaf?
	Leaves        []*LogLeaf     `protobuf:"bytes,2,rep,name=leaves" json:"leaves,omitempty"`
	SignedLogRoot *SignedLogRoot `protobuf:"bytes,3,opt,name=signed_log_root,json=signedLogRoot" json:"signed_log_root,omitempty"`
}

func (m *GetLeavesByHashResponse) Reset()                    { *m = GetLeavesByHashResponse{} }
func (m *GetLeavesByHashResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLeavesByHashResponse) ProtoMessage()               {}
func (*GetLeavesByHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *GetLeavesByHashResponse) GetLeaves() []*LogLeaf {
	if m != nil {
		return m.Leaves
	}
	return nil
}

func (m *GetLeavesByHashResponse) GetSignedLogRoot() *SignedLogRoot {
	if m != nil {
		return m.SignedLogRoot
	}
	return nil
}

// A result of submitting an entry to the log. Output only.
// TODO(pavelkalinnikov): Consider renaming it to AddLogLeafResult or the like.
type QueuedLogLeaf struct {
	// The leaf as it was stored by Trillian. Empty unless `status.code` is:
	//  - `google.rpc.OK`: the `leaf` data is the same as in the request.
	//  - `google.rpc.ALREADY_EXISTS` or 'google.rpc.FAILED_PRECONDITION`: the
	//    `leaf` is the conflicting one already in the log.
	Leaf *LogLeaf `protobuf:"bytes,1,opt,name=leaf" json:"leaf,omitempty"`
	// The status of adding the leaf.
	//  - `google.rpc.OK`: successfully added.
	//  - `google.rpc.ALREADY_EXISTS`: the leaf is a duplicate of an already
	//    existing one. Either `leaf_identity_hash` is the same in the `LOG`
	//    mode, or `leaf_index` in the `PREORDERED_LOG`.
	//  - `google.rpc.FAILED_PRECONDITION`: A conflicting entry is already
	//    present in the log, e.g., same `leaf_index` but different `leaf_data`.
	Status *google_rpc.Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *QueuedLogLeaf) Reset()                    { *m = QueuedLogLeaf{} }
func (m *QueuedLogLeaf) String() string            { return proto.CompactTextString(m) }
func (*QueuedLogLeaf) ProtoMessage()               {}
func (*QueuedLogLeaf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *QueuedLogLeaf) GetLeaf() *LogLeaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *QueuedLogLeaf) GetStatus() *google_rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// A leaf of the log's Merkle tree, corresponds to a single log entry. Each leaf
// has a unique `leaf_index` in the scope of this tree.
type LogLeaf struct {
	// Output only. The hash over `leaf_data`.
	MerkleLeafHash []byte `protobuf:"bytes,1,opt,name=merkle_leaf_hash,json=merkleLeafHash,proto3" json:"merkle_leaf_hash,omitempty"`
	// Required. The arbitrary data associated with this log entry. Validity of
	// this field is governed by the call site (personality).
	LeafValue []byte `protobuf:"bytes,2,opt,name=leaf_value,json=leafValue,proto3" json:"leaf_value,omitempty"`
	// The arbitrary metadata, e.g., a timestamp.
	ExtraData []byte `protobuf:"bytes,3,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	// Output only in `LOG` mode. Required in `PREORDERED_LOG` mode.
	// The index of the leaf in the Merkle tree, i.e., the position of the
	// corresponding entry in the log. For normal logs this value will be
	// assigned by the LogSigner.
	LeafIndex int64 `protobuf:"varint,4,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	// The hash over the identity of this leaf. If empty, assumed to be the same
	// as `merkle_leaf_hash`. It is a mechanism for the personality to provide a
	// hint to Trillian that two leaves should be considered "duplicates" even
	// though their `leaf_value`s differ.
	//
	// E.g., in a CT personality multiple `add-chain` calls for an identical
	// certificate would produce differing `leaf_data` bytes (due to the
	// presence of SCT elements), with just this information Trillian would be
	// unable to determine that. Within the context of the CT personality, these
	// entries are dupes, so it sets `leaf_identity_hash` to `H(cert)`, which
	// allows Trillian to detect the duplicates.
	//
	// Continuing the CT example, for a CT mirror personality (which must allow
	// dupes since the source log could contain them), the part of the
	// personality which fetches and submits the entries might set
	// `leaf_identity_hash` to `H(leaf_index||cert)`.
	// TODO(pavelkalinnikov): Consider instead using `H(cert)` and allowing
	// identity hash dupes in `PREORDERED_LOG` mode, for it can later be
	// upgraded to `LOG` which will need to correctly detect duplicates with
	// older entries when new ones get queued.
	LeafIdentityHash []byte `protobuf:"bytes,5,opt,name=leaf_identity_hash,json=leafIdentityHash,proto3" json:"leaf_identity_hash,omitempty"`
	// Output only. The time at which this leaf was passed to `QueueLeaves`.
	// This value will be determined and set by the LogServer. Equals zero if
	// the entry was submitted without queuing.
	QueueTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,6,opt,name=queue_timestamp,json=queueTimestamp" json:"queue_timestamp,omitempty"`
	// Output only. The time at which this leaf was integrated into the tree.
	// This value will be determined and set by the LogSigner.
	IntegrateTimestamp *google_protobuf1.Timestamp `protobuf:"bytes,7,opt,name=integrate_timestamp,json=integrateTimestamp" json:"integrate_timestamp,omitempty"`
}

func (m *LogLeaf) Reset()                    { *m = LogLeaf{} }
func (m *LogLeaf) String() string            { return proto.CompactTextString(m) }
func (*LogLeaf) ProtoMessage()               {}
func (*LogLeaf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *LogLeaf) GetMerkleLeafHash() []byte {
	if m != nil {
		return m.MerkleLeafHash
	}
	return nil
}

func (m *LogLeaf) GetLeafValue() []byte {
	if m != nil {
		return m.LeafValue
	}
	return nil
}

func (m *LogLeaf) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *LogLeaf) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *LogLeaf) GetLeafIdentityHash() []byte {
	if m != nil {
		return m.LeafIdentityHash
	}
	return nil
}

func (m *LogLeaf) GetQueueTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.QueueTimestamp
	}
	return nil
}

func (m *LogLeaf) GetIntegrateTimestamp() *google_protobuf1.Timestamp {
	if m != nil {
		return m.IntegrateTimestamp
	}
	return nil
}

// A consistency or inclusion proof for a Merkle tree. Output only.
type Proof struct {
	LeafIndex int64    `protobuf:"varint,1,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	Hashes    [][]byte `protobuf:"bytes,3,rep,name=hashes,proto3" json:"hashes,omitempty"`
}

func (m *Proof) Reset()                    { *m = Proof{} }
func (m *Proof) String() string            { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()               {}
func (*Proof) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *Proof) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *Proof) GetHashes() [][]byte {
	if m != nil {
		return m.Hashes
	}
	return nil
}

func init() {
	proto.RegisterType((*ChargeTo)(nil), "trillian.ChargeTo")
	proto.RegisterType((*QueueLeafRequest)(nil), "trillian.QueueLeafRequest")
	proto.RegisterType((*QueueLeafResponse)(nil), "trillian.QueueLeafResponse")
	proto.RegisterType((*AddSequencedLeafRequest)(nil), "trillian.AddSequencedLeafRequest")
	proto.RegisterType((*AddSequencedLeafResponse)(nil), "trillian.AddSequencedLeafResponse")
	proto.RegisterType((*GetInclusionProofRequest)(nil), "trillian.GetInclusionProofRequest")
	proto.RegisterType((*GetInclusionProofResponse)(nil), "trillian.GetInclusionProofResponse")
	proto.RegisterType((*GetInclusionProofByHashRequest)(nil), "trillian.GetInclusionProofByHashRequest")
	proto.RegisterType((*GetInclusionProofByHashResponse)(nil), "trillian.GetInclusionProofByHashResponse")
	proto.RegisterType((*GetConsistencyProofRequest)(nil), "trillian.GetConsistencyProofRequest")
	proto.RegisterType((*GetConsistencyProofResponse)(nil), "trillian.GetConsistencyProofResponse")
	proto.RegisterType((*GetLatestSignedLogRootRequest)(nil), "trillian.GetLatestSignedLogRootRequest")
	proto.RegisterType((*GetLatestSignedLogRootResponse)(nil), "trillian.GetLatestSignedLogRootResponse")
	proto.RegisterType((*GetSequencedLeafCountRequest)(nil), "trillian.GetSequencedLeafCountRequest")
	proto.RegisterType((*GetSequencedLeafCountResponse)(nil), "trillian.GetSequencedLeafCountResponse")
	proto.RegisterType((*GetEntryAndProofRequest)(nil), "trillian.GetEntryAndProofRequest")
	proto.RegisterType((*GetEntryAndProofResponse)(nil), "trillian.GetEntryAndProofResponse")
	proto.RegisterType((*InitLogRequest)(nil), "trillian.InitLogRequest")
	proto.RegisterType((*InitLogResponse)(nil), "trillian.InitLogResponse")
	proto.RegisterType((*QueueLeavesRequest)(nil), "trillian.QueueLeavesRequest")
	proto.RegisterType((*QueueLeavesResponse)(nil), "trillian.QueueLeavesResponse")
	proto.RegisterType((*AddSequencedLeavesRequest)(nil), "trillian.AddSequencedLeavesRequest")
	proto.RegisterType((*AddSequencedLeavesResponse)(nil), "trillian.AddSequencedLeavesResponse")
	proto.RegisterType((*GetLeavesByIndexRequest)(nil), "trillian.GetLeavesByIndexRequest")
	proto.RegisterType((*GetLeavesByIndexResponse)(nil), "trillian.GetLeavesByIndexResponse")
	proto.RegisterType((*GetLeavesByRangeRequest)(nil), "trillian.GetLeavesByRangeRequest")
	proto.RegisterType((*GetLeavesByRangeResponse)(nil), "trillian.GetLeavesByRangeResponse")
	proto.RegisterType((*GetLeavesByHashRequest)(nil), "trillian.GetLeavesByHashRequest")
	proto.RegisterType((*GetLeavesByHashResponse)(nil), "trillian.GetLeavesByHashResponse")
	proto.RegisterType((*QueuedLogLeaf)(nil), "trillian.QueuedLogLeaf")
	proto.RegisterType((*LogLeaf)(nil), "trillian.LogLeaf")
	proto.RegisterType((*Proof)(nil), "trillian.Proof")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TrillianLog service

type TrillianLogClient interface {
	// Adds a single leaf to the queue.
	QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*QueueLeafResponse, error)
	// Adds a single leaf with an assigned sequence number.
	// Warning: This RPC is under development, don't use it.
	AddSequencedLeaf(ctx context.Context, in *AddSequencedLeafRequest, opts ...grpc.CallOption) (*AddSequencedLeafResponse, error)
	// Returns inclusion proof for a leaf with a given index in a given tree.
	GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error)
	// Returns inclusion proof for a leaf with a given identity hash in a given
	// tree.
	GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error)
	// Returns consistency proof between two versions of a given tree.
	GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error)
	// Returns the latest signed log root for a given tree. Corresponds to the
	// ReadOnlyLogTreeTX.LatestSignedLogRoot storage interface.
	GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error)
	// Returns the total number of leaves that have been integrated into the
	// given tree. Corresponds to the ReadOnlyLogTreeTX.GetSequencedLeafCount
	// storage interface.
	// DO NOT USE - FOR DEBUGGING/TEST ONLY
	GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error)
	// Returns log entry and the corresponding inclusion proof for a given leaf
	// index in a given tree. If the requested tree is unavailable but the leaf is in scope
	// for the current tree, return a proof in that tree instead.
	GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error)
	InitLog(ctx context.Context, in *InitLogRequest, opts ...grpc.CallOption) (*InitLogResponse, error)
	// Adds a batch of leaves to the queue.
	QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error)
	// Stores leaves from the provided batch and associates them with the log
	// positions according to the `LeafIndex` field. The indices must be
	// contiguous.
	//
	// Warning: This RPC is under development, don't use it.
	AddSequencedLeaves(ctx context.Context, in *AddSequencedLeavesRequest, opts ...grpc.CallOption) (*AddSequencedLeavesResponse, error)
	// Returns a batch of leaves located in the provided positions.
	GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error)
	// Returns a batch of leaves in a sequential range.
	GetLeavesByRange(ctx context.Context, in *GetLeavesByRangeRequest, opts ...grpc.CallOption) (*GetLeavesByRangeResponse, error)
	// Returns a batch of leaves by their `merkle_leaf_hash` values.
	GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error)
}

type trillianLogClient struct {
	cc *grpc.ClientConn
}

func NewTrillianLogClient(cc *grpc.ClientConn) TrillianLogClient {
	return &trillianLogClient{cc}
}

func (c *trillianLogClient) QueueLeaf(ctx context.Context, in *QueueLeafRequest, opts ...grpc.CallOption) (*QueueLeafResponse, error) {
	out := new(QueueLeafResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) AddSequencedLeaf(ctx context.Context, in *AddSequencedLeafRequest, opts ...grpc.CallOption) (*AddSequencedLeafResponse, error) {
	out := new(AddSequencedLeafResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/AddSequencedLeaf", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProof(ctx context.Context, in *GetInclusionProofRequest, opts ...grpc.CallOption) (*GetInclusionProofResponse, error) {
	out := new(GetInclusionProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetInclusionProofByHash(ctx context.Context, in *GetInclusionProofByHashRequest, opts ...grpc.CallOption) (*GetInclusionProofByHashResponse, error) {
	out := new(GetInclusionProofByHashResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetInclusionProofByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetConsistencyProof(ctx context.Context, in *GetConsistencyProofRequest, opts ...grpc.CallOption) (*GetConsistencyProofResponse, error) {
	out := new(GetConsistencyProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetConsistencyProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLatestSignedLogRoot(ctx context.Context, in *GetLatestSignedLogRootRequest, opts ...grpc.CallOption) (*GetLatestSignedLogRootResponse, error) {
	out := new(GetLatestSignedLogRootResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLatestSignedLogRoot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetSequencedLeafCount(ctx context.Context, in *GetSequencedLeafCountRequest, opts ...grpc.CallOption) (*GetSequencedLeafCountResponse, error) {
	out := new(GetSequencedLeafCountResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetSequencedLeafCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetEntryAndProof(ctx context.Context, in *GetEntryAndProofRequest, opts ...grpc.CallOption) (*GetEntryAndProofResponse, error) {
	out := new(GetEntryAndProofResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetEntryAndProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) InitLog(ctx context.Context, in *InitLogRequest, opts ...grpc.CallOption) (*InitLogResponse, error) {
	out := new(InitLogResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/InitLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) QueueLeaves(ctx context.Context, in *QueueLeavesRequest, opts ...grpc.CallOption) (*QueueLeavesResponse, error) {
	out := new(QueueLeavesResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/QueueLeaves", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) AddSequencedLeaves(ctx context.Context, in *AddSequencedLeavesRequest, opts ...grpc.CallOption) (*AddSequencedLeavesResponse, error) {
	out := new(AddSequencedLeavesResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/AddSequencedLeaves", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByIndex(ctx context.Context, in *GetLeavesByIndexRequest, opts ...grpc.CallOption) (*GetLeavesByIndexResponse, error) {
	out := new(GetLeavesByIndexResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByRange(ctx context.Context, in *GetLeavesByRangeRequest, opts ...grpc.CallOption) (*GetLeavesByRangeResponse, error) {
	out := new(GetLeavesByRangeResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByRange", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trillianLogClient) GetLeavesByHash(ctx context.Context, in *GetLeavesByHashRequest, opts ...grpc.CallOption) (*GetLeavesByHashResponse, error) {
	out := new(GetLeavesByHashResponse)
	err := grpc.Invoke(ctx, "/trillian.TrillianLog/GetLeavesByHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TrillianLog service

type TrillianLogServer interface {
	// Adds a single leaf to the queue.
	QueueLeaf(context.Context, *QueueLeafRequest) (*QueueLeafResponse, error)
	// Adds a single leaf with an assigned sequence number.
	// Warning: This RPC is under development, don't use it.
	AddSequencedLeaf(context.Context, *AddSequencedLeafRequest) (*AddSequencedLeafResponse, error)
	// Returns inclusion proof for a leaf with a given index in a given tree.
	GetInclusionProof(context.Context, *GetInclusionProofRequest) (*GetInclusionProofResponse, error)
	// Returns inclusion proof for a leaf with a given identity hash in a given
	// tree.
	GetInclusionProofByHash(context.Context, *GetInclusionProofByHashRequest) (*GetInclusionProofByHashResponse, error)
	// Returns consistency proof between two versions of a given tree.
	GetConsistencyProof(context.Context, *GetConsistencyProofRequest) (*GetConsistencyProofResponse, error)
	// Returns the latest signed log root for a given tree. Corresponds to the
	// ReadOnlyLogTreeTX.LatestSignedLogRoot storage interface.
	GetLatestSignedLogRoot(context.Context, *GetLatestSignedLogRootRequest) (*GetLatestSignedLogRootResponse, error)
	// Returns the total number of leaves that have been integrated into the
	// given tree. Corresponds to the ReadOnlyLogTreeTX.GetSequencedLeafCount
	// storage interface.
	// DO NOT USE - FOR DEBUGGING/TEST ONLY
	GetSequencedLeafCount(context.Context, *GetSequencedLeafCountRequest) (*GetSequencedLeafCountResponse, error)
	// Returns log entry and the corresponding inclusion proof for a given leaf
	// index in a given tree. If the requested tree is unavailable but the leaf is in scope
	// for the current tree, return a proof in that tree instead.
	GetEntryAndProof(context.Context, *GetEntryAndProofRequest) (*GetEntryAndProofResponse, error)
	InitLog(context.Context, *InitLogRequest) (*InitLogResponse, error)
	// Adds a batch of leaves to the queue.
	QueueLeaves(context.Context, *QueueLeavesRequest) (*QueueLeavesResponse, error)
	// Stores leaves from the provided batch and associates them with the log
	// positions according to the `LeafIndex` field. The indices must be
	// contiguous.
	//
	// Warning: This RPC is under development, don't use it.
	AddSequencedLeaves(context.Context, *AddSequencedLeavesRequest) (*AddSequencedLeavesResponse, error)
	// Returns a batch of leaves located in the provided positions.
	GetLeavesByIndex(context.Context, *GetLeavesByIndexRequest) (*GetLeavesByIndexResponse, error)
	// Returns a batch of leaves in a sequential range.
	GetLeavesByRange(context.Context, *GetLeavesByRangeRequest) (*GetLeavesByRangeResponse, error)
	// Returns a batch of leaves by their `merkle_leaf_hash` values.
	GetLeavesByHash(context.Context, *GetLeavesByHashRequest) (*GetLeavesByHashResponse, error)
}

func RegisterTrillianLogServer(s *grpc.Server, srv TrillianLogServer) {
	s.RegisterService(&_TrillianLog_serviceDesc, srv)
}

func _TrillianLog_QueueLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaf(ctx, req.(*QueueLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_AddSequencedLeaf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSequencedLeafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).AddSequencedLeaf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/AddSequencedLeaf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).AddSequencedLeaf(ctx, req.(*AddSequencedLeafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProof(ctx, req.(*GetInclusionProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetInclusionProofByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInclusionProofByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetInclusionProofByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetInclusionProofByHash(ctx, req.(*GetInclusionProofByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetConsistencyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsistencyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetConsistencyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetConsistencyProof(ctx, req.(*GetConsistencyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLatestSignedLogRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestSignedLogRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLatestSignedLogRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLatestSignedLogRoot(ctx, req.(*GetLatestSignedLogRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetSequencedLeafCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSequencedLeafCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetSequencedLeafCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetSequencedLeafCount(ctx, req.(*GetSequencedLeafCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetEntryAndProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntryAndProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetEntryAndProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetEntryAndProof(ctx, req.(*GetEntryAndProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_InitLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).InitLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/InitLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).InitLog(ctx, req.(*InitLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_QueueLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).QueueLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/QueueLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).QueueLeaves(ctx, req.(*QueueLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_AddSequencedLeaves_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSequencedLeavesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).AddSequencedLeaves(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/AddSequencedLeaves",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).AddSequencedLeaves(ctx, req.(*AddSequencedLeavesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByIndex(ctx, req.(*GetLeavesByIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByRange(ctx, req.(*GetLeavesByRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrillianLog_GetLeavesByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeavesByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trillian.TrillianLog/GetLeavesByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrillianLogServer).GetLeavesByHash(ctx, req.(*GetLeavesByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TrillianLog_serviceDesc = grpc.ServiceDesc{
	ServiceName: "trillian.TrillianLog",
	HandlerType: (*TrillianLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueueLeaf",
			Handler:    _TrillianLog_QueueLeaf_Handler,
		},
		{
			MethodName: "AddSequencedLeaf",
			Handler:    _TrillianLog_AddSequencedLeaf_Handler,
		},
		{
			MethodName: "GetInclusionProof",
			Handler:    _TrillianLog_GetInclusionProof_Handler,
		},
		{
			MethodName: "GetInclusionProofByHash",
			Handler:    _TrillianLog_GetInclusionProofByHash_Handler,
		},
		{
			MethodName: "GetConsistencyProof",
			Handler:    _TrillianLog_GetConsistencyProof_Handler,
		},
		{
			MethodName: "GetLatestSignedLogRoot",
			Handler:    _TrillianLog_GetLatestSignedLogRoot_Handler,
		},
		{
			MethodName: "GetSequencedLeafCount",
			Handler:    _TrillianLog_GetSequencedLeafCount_Handler,
		},
		{
			MethodName: "GetEntryAndProof",
			Handler:    _TrillianLog_GetEntryAndProof_Handler,
		},
		{
			MethodName: "InitLog",
			Handler:    _TrillianLog_InitLog_Handler,
		},
		{
			MethodName: "QueueLeaves",
			Handler:    _TrillianLog_QueueLeaves_Handler,
		},
		{
			MethodName: "AddSequencedLeaves",
			Handler:    _TrillianLog_AddSequencedLeaves_Handler,
		},
		{
			MethodName: "GetLeavesByIndex",
			Handler:    _TrillianLog_GetLeavesByIndex_Handler,
		},
		{
			MethodName: "GetLeavesByRange",
			Handler:    _TrillianLog_GetLeavesByRange_Handler,
		},
		{
			MethodName: "GetLeavesByHash",
			Handler:    _TrillianLog_GetLeavesByHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trillian_log_api.proto",
}

func init() { proto.RegisterFile("trillian_log_api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xef, 0xc5, 0x89, 0xe3, 0x4c, 0x9a, 0x38, 0xd9, 0xd0, 0xc6, 0xb9, 0x34, 0x6d, 0x7a, 0x69,
	0x5a, 0x37, 0x94, 0x1c, 0x29, 0x42, 0xa0, 0xa8, 0x02, 0x35, 0x29, 0x0a, 0xa1, 0x06, 0xca, 0x25,
	0x42, 0x15, 0x3c, 0x9c, 0xce, 0xe7, 0xcd, 0xe5, 0x84, 0x73, 0xeb, 0xde, 0xad, 0xa3, 0xba, 0x55,
	0x25, 0xfe, 0xa8, 0xfc, 0x79, 0x80, 0x17, 0x78, 0xe8, 0x0b, 0x7f, 0xde, 0x50, 0xbf, 0x00, 0x1f,
	0x03, 0x21, 0xf1, 0x15, 0x78, 0xe0, 0x63, 0xa0, 0xdb, 0xdd, 0xf3, 0xfd, 0xf1, 0xdd, 0xd9, 0x2e,
	0x6d, 0xe1, 0xcd, 0x37, 0x3b, 0x3b, 0xf3, 0xfb, 0xcd, 0xee, 0xcc, 0xce, 0x18, 0x4e, 0x53, 0xd7,
	0x6e, 0x36, 0x6d, 0xc3, 0xd1, 0x9b, 0xc4, 0xd2, 0x8d, 0x96, 0xbd, 0xde, 0x72, 0x09, 0x25, 0xa8,
	0x14, 0xc8, 0xe5, 0x33, 0x16, 0x21, 0x56, 0x13, 0xab, 0x46, 0xcb, 0x56, 0x0d, 0xc7, 0x21, 0xd4,
	0xa0, 0x36, 0x71, 0x3c, 0xae, 0x27, 0x9f, 0x13, 0xab, 0xec, 0xab, 0xde, 0x3e, 0x50, 0xa9, 0x7d,
	0x84, 0x3d, 0x6a, 0x1c, 0xb5, 0x84, 0xc2, 0xbc, 0x50, 0x70, 0x5b, 0xa6, 0xea, 0x51, 0x83, 0xb6,
	0x83, 0x9d, 0xd3, 0x81, 0x07, 0xfe, 0xad, 0x9c, 0x85, 0xd2, 0xf6, 0xa1, 0xe1, 0x5a, 0x78, 0x9f,
	0x20, 0x04, 0xa3, 0x6d, 0x0f, 0xbb, 0x15, 0x69, 0xb9, 0x50, 0x9d, 0xd0, 0xd8, 0x6f, 0xe5, 0x33,
	0x09, 0x66, 0x3e, 0x68, 0xe3, 0x36, 0xae, 0x61, 0xe3, 0x40, 0xc3, 0x77, 0xda, 0xd8, 0xa3, 0xe8,
	0x14, 0x14, 0x7d, 0xdc, 0x76, 0xa3, 0x22, 0x2d, 0x4b, 0xd5, 0x82, 0x36, 0xd6, 0x24, 0xd6, 0x6e,
	0x03, 0xad, 0xc2, 0x68, 0x13, 0x1b, 0x07, 0x95, 0x91, 0x65, 0xa9, 0x3a, 0x79, 0x75, 0x76, 0xbd,
	0xeb, 0xaa, 0x46, 0x2c, 0xb6, 0x9d, 0x2d, 0x23, 0x15, 0x26, 0x4c, 0xe6, 0x52, 0xa7, 0xa4, 0x52,
	0x60, 0xba, 0x28, 0xd4, 0x0d, 0xd0, 0x68, 0x25, 0x53, 0xfc, 0x52, 0xde, 0x85, 0xd9, 0x08, 0x04,
	0xaf, 0x45, 0x1c, 0x0f, 0xa3, 0xd7, 0x61, 0xf2, 0x8e, 0x2f, 0x6c, 0xe8, 0x11, 0x9f, 0xf3, 0xa1,
	0x1d, 0xb6, 0xa3, 0x11, 0x78, 0x06, 0xae, 0xeb, 0xff, 0x56, 0xbe, 0x96, 0x60, 0xfe, 0x7a, 0xa3,
	0xb1, 0xe7, 0x93, 0x71, 0x4c, 0x2e, 0xfc, 0x8f, 0x98, 0xdd, 0x84, 0x4a, 0x2f, 0x12, 0x41, 0x50,
	0x85, 0xa2, 0x8b, 0xbd, 0x76, 0x93, 0xf6, 0xe3, 0x26, 0xd4, 0x94, 0x9f, 0x24, 0xa8, 0xec, 0x60,
	0xba, 0xeb, 0x98, 0xcd, 0xb6, 0x67, 0x13, 0xe7, 0x96, 0x4b, 0x48, 0x3f, 0x62, 0x4b, 0x00, 0x3e,
	0x72, 0xdd, 0x76, 0x1a, 0xf8, 0x2e, 0x73, 0x54, 0xd0, 0x26, 0x7c, 0xc9, 0xae, 0x2f, 0x40, 0x8b,
	0x30, 0x41, 0x5d, 0x8c, 0x75, 0xcf, 0xbe, 0x87, 0x19, 0xa1, 0x82, 0x56, 0xf2, 0x05, 0x7b, 0xf6,
	0x3d, 0x1c, 0x67, 0x3b, 0x3a, 0x00, 0xdb, 0x2f, 0x24, 0x58, 0x48, 0x01, 0x28, 0xf8, 0xae, 0xc2,
	0x58, 0xcb, 0x17, 0x08, 0xba, 0xe5, 0xd0, 0x14, 0xd7, 0xe3, 0xab, 0xe8, 0x4d, 0x28, 0x7b, 0xb6,
	0xe5, 0xf8, 0xe7, 0x4e, 0x2c, 0xdd, 0x25, 0x84, 0x8a, 0x48, 0x47, 0xe2, 0xb3, 0xc7, 0x14, 0x6a,
	0xc4, 0xd2, 0x08, 0xa1, 0xda, 0x94, 0x17, 0xfd, 0x54, 0x7e, 0x97, 0xe0, 0x6c, 0x0f, 0x8a, 0xad,
	0xce, 0xdb, 0x86, 0x77, 0xd8, 0x27, 0x58, 0x8b, 0xc0, 0x42, 0xa3, 0x1f, 0x1a, 0xde, 0x21, 0x43,
	0x79, 0x52, 0x2b, 0xf9, 0x02, 0x7f, 0x6b, 0x7e, 0xa8, 0xd6, 0x60, 0x96, 0xb8, 0x0d, 0xec, 0xea,
	0xf5, 0x8e, 0xee, 0x89, 0xd3, 0x66, 0x21, 0x2b, 0x69, 0x65, 0xb6, 0xb0, 0xd5, 0x09, 0x2e, 0x41,
	0x3c, 0xac, 0x63, 0x03, 0x84, 0xf5, 0x1b, 0x09, 0xce, 0x65, 0x12, 0xea, 0x0d, 0x6e, 0xe1, 0x59,
	0x06, 0xf7, 0x37, 0x09, 0xe4, 0x1d, 0x4c, 0xb7, 0x89, 0xe3, 0xd9, 0x1e, 0xc5, 0x8e, 0xd9, 0x19,
	0xe4, 0x16, 0x5e, 0x84, 0xf2, 0x81, 0xed, 0x7a, 0x54, 0x0f, 0x23, 0xc8, 0xaf, 0xe2, 0x14, 0x13,
	0xef, 0x07, 0x61, 0xac, 0xc2, 0x8c, 0x87, 0x4d, 0xe2, 0x34, 0xf4, 0x64, 0xa8, 0xa7, 0xb9, 0x7c,
	0xff, 0x89, 0xef, 0xe6, 0x43, 0x09, 0x16, 0x53, 0x81, 0x3f, 0xe7, 0xdb, 0x69, 0xc1, 0xd2, 0x0e,
	0xa6, 0x35, 0x83, 0x62, 0x8f, 0xc6, 0x15, 0xf3, 0x43, 0x18, 0x23, 0x3c, 0x32, 0x00, 0x61, 0x83,
	0x65, 0x41, 0xaa, 0x23, 0x41, 0x39, 0x85, 0xcb, 0xc8, 0x50, 0x5c, 0x0e, 0xe0, 0xcc, 0x0e, 0xa6,
	0xb1, 0xea, 0xb6, 0x4d, 0xda, 0xce, 0x53, 0xa7, 0xf2, 0x06, 0x8b, 0x59, 0x9a, 0x1f, 0xc1, 0x24,
	0xa8, 0x72, 0xa6, 0x2f, 0x8d, 0x56, 0x39, 0xa6, 0xa6, 0xfc, 0x28, 0xc1, 0xfc, 0x0e, 0xa6, 0x6f,
	0x39, 0xd4, 0xed, 0x5c, 0x77, 0x1a, 0xff, 0xbb, 0xba, 0xf9, 0x98, 0x17, 0xf6, 0x04, 0xbe, 0xe1,
	0x2e, 0x66, 0xf0, 0x82, 0x15, 0xf2, 0x5f, 0xb0, 0x94, 0x33, 0x1f, 0x1d, 0xea, 0xcc, 0x6f, 0xc3,
	0xf4, 0xae, 0x63, 0x53, 0xff, 0xf3, 0x29, 0x9f, 0xf2, 0x0d, 0x28, 0x77, 0x2d, 0x0b, 0xee, 0x1b,
	0x30, 0x6e, 0xba, 0xd8, 0xa0, 0x98, 0xdb, 0xce, 0x41, 0x19, 0xe8, 0x29, 0x5f, 0x49, 0x80, 0x82,
	0x66, 0xe2, 0x18, 0x7b, 0x7d, 0x40, 0x5e, 0x86, 0x62, 0x93, 0xe9, 0x89, 0xba, 0x99, 0x12, 0x37,
	0xa1, 0x30, 0xfc, 0xdb, 0xbf, 0x07, 0x73, 0x31, 0x20, 0x82, 0xd3, 0x35, 0x98, 0x0a, 0xfb, 0x9a,
	0xd0, 0x73, 0xe6, 0xeb, 0x7f, 0xb2, 0xdb, 0xd9, 0x1c, 0x63, 0x4f, 0xf9, 0x4e, 0x82, 0x85, 0x44,
	0x47, 0xf1, 0xec, 0x58, 0x0e, 0x72, 0x77, 0xdf, 0x07, 0x39, 0x0d, 0x4f, 0x78, 0x80, 0xbc, 0x79,
	0xe9, 0x4b, 0x33, 0xd0, 0x53, 0x3e, 0xe5, 0xc9, 0xca, 0x0d, 0x6d, 0x75, 0x58, 0xbe, 0x0d, 0x99,
	0xac, 0x85, 0x78, 0xb2, 0x0e, 0xfd, 0xe0, 0x7e, 0xc9, 0xf3, 0x31, 0x01, 0x41, 0x50, 0x1a, 0x22,
	0x98, 0xff, 0xfa, 0xb1, 0x78, 0x14, 0x8f, 0x85, 0x66, 0x38, 0x16, 0xee, 0x13, 0x8b, 0x73, 0x30,
	0xe9, 0x51, 0xc3, 0xa5, 0xb1, 0xca, 0x05, 0x4c, 0xc4, 0xa3, 0xf1, 0x02, 0x8c, 0xf1, 0x32, 0xc9,
	0xcb, 0x16, 0xff, 0x18, 0xfe, 0xdc, 0x13, 0x31, 0x12, 0xd0, 0x7a, 0x62, 0x24, 0x3d, 0x41, 0x8c,
	0x86, 0x7b, 0x84, 0x1e, 0x4b, 0x70, 0x3a, 0x02, 0x64, 0xf8, 0x36, 0xaf, 0x10, 0x6b, 0xf3, 0x52,
	0x3b, 0xb9, 0xc2, 0x53, 0xea, 0xe4, 0x1e, 0xc6, 0xcf, 0x33, 0xd6, 0xc1, 0x3d, 0xcf, 0x7b, 0x55,
	0x87, 0xa9, 0x58, 0xf6, 0x75, 0x5f, 0x0f, 0x29, 0xff, 0xf5, 0x58, 0x83, 0x22, 0x1f, 0x36, 0xbb,
	0x05, 0x9d, 0x8f, 0xa1, 0xeb, 0x6e, 0xcb, 0x5c, 0xdf, 0x63, 0x2b, 0x9a, 0xd0, 0x50, 0xfe, 0x18,
	0x81, 0xf1, 0xc0, 0x7c, 0x15, 0x66, 0x8e, 0xb0, 0xfb, 0x49, 0x13, 0xeb, 0x61, 0xe0, 0x25, 0xd6,
	0x5f, 0x4f, 0x73, 0x79, 0x2d, 0x08, 0x7f, 0x90, 0xca, 0xc7, 0x46, 0xb3, 0x8d, 0x45, 0x0f, 0xce,
	0x4e, 0xeb, 0x43, 0x5f, 0xe0, 0x2f, 0xe3, 0xbb, 0xd4, 0x35, 0xf4, 0x86, 0x41, 0x0d, 0x46, 0xfa,
	0xa4, 0x36, 0xc1, 0x24, 0x37, 0x0c, 0x6a, 0x24, 0x0a, 0xc1, 0x68, 0xf2, 0xd5, 0xbe, 0x02, 0x88,
	0x2f, 0x37, 0xb0, 0x43, 0x6d, 0xda, 0xe1, 0x40, 0xc6, 0x98, 0x95, 0x19, 0xa6, 0x26, 0x16, 0x18,
	0x94, 0x6d, 0x28, 0xb3, 0xd2, 0xab, 0x77, 0x67, 0xef, 0x4a, 0x91, 0xb1, 0x96, 0x03, 0xd6, 0xc1,
	0x74, 0xbe, 0xbe, 0x1f, 0x68, 0x68, 0xd3, 0x6c, 0x4b, 0xf7, 0x1b, 0xdd, 0x84, 0x39, 0xdb, 0xa1,
	0xd8, 0x72, 0x0d, 0x1a, 0x35, 0x34, 0xde, 0xd7, 0x10, 0xea, 0x6e, 0xeb, 0xca, 0x94, 0x1b, 0x30,
	0xc6, 0xde, 0xfc, 0x04, 0x4f, 0x29, 0xc9, 0xf3, 0x34, 0x14, 0x7d, 0x66, 0xd8, 0xab, 0x14, 0xd8,
	0xed, 0x16, 0x5f, 0xef, 0x8c, 0x96, 0x46, 0x66, 0x0a, 0x57, 0xff, 0x9e, 0x82, 0xc9, 0x7d, 0x71,
	0xbe, 0x35, 0x62, 0x21, 0x07, 0x26, 0xba, 0xd3, 0x37, 0x92, 0x13, 0xf5, 0x39, 0x32, 0x3b, 0xcb,
	0x8b, 0xa9, 0x6b, 0xfc, 0xfa, 0x2a, 0xd5, 0xcf, 0xff, 0xfc, 0xeb, 0xfb, 0x11, 0x45, 0x59, 0x52,
	0x8f, 0x37, 0xea, 0x98, 0x1a, 0x1b, 0x6a, 0x93, 0x58, 0x9e, 0x7a, 0x9f, 0x27, 0xe0, 0x03, 0x95,
	0x5f, 0xdd, 0x4d, 0x69, 0x0d, 0x7d, 0x2b, 0xc1, 0x4c, 0x72, 0x28, 0x46, 0xe7, 0x43, 0xdb, 0x19,
	0xa3, 0xbb, 0xac, 0xe4, 0xa9, 0x08, 0x14, 0x57, 0x19, 0x8a, 0x2b, 0xca, 0xa5, 0x7c, 0x14, 0x41,
	0x62, 0x37, 0x7c, 0x3c, 0xbf, 0x48, 0x30, 0xdb, 0x33, 0x5e, 0xa1, 0x88, 0xb7, 0xac, 0x99, 0x5b,
	0x5e, 0xc9, 0xd5, 0x11, 0x90, 0xb6, 0x18, 0xa4, 0x6b, 0x68, 0x33, 0x17, 0x92, 0x7a, 0x3f, 0x3c,
	0xd0, 0x07, 0x9b, 0x76, 0x60, 0x4a, 0xe7, 0xcd, 0xdd, 0xaf, 0xbc, 0x6e, 0xa4, 0x4d, 0x80, 0xa8,
	0x9a, 0x03, 0x22, 0x56, 0x0e, 0xe5, 0xcb, 0x03, 0x68, 0x0a, 0xd0, 0xaf, 0x31, 0xd0, 0x1b, 0x48,
	0xcd, 0x8f, 0x63, 0x88, 0xb3, 0xce, 0x93, 0x09, 0xfd, 0x20, 0xc1, 0x5c, 0xca, 0x98, 0x85, 0x2e,
	0xc4, 0x7c, 0x67, 0x8c, 0x8f, 0xf2, 0x6a, 0x1f, 0x2d, 0x81, 0xee, 0x65, 0x86, 0x6e, 0x0d, 0x55,
	0xd3, 0xd1, 0x6d, 0x9a, 0xe1, 0x46, 0x11, 0xc0, 0x47, 0xe2, 0x91, 0xe8, 0x9d, 0x86, 0xd0, 0xa5,
	0x98, 0xcf, 0xec, 0xc1, 0x4c, 0xae, 0xf6, 0x57, 0x14, 0xf8, 0x5e, 0x64, 0xf8, 0x56, 0xd1, 0x4a,
	0x46, 0xf4, 0xfc, 0x8a, 0xed, 0x6d, 0x36, 0x99, 0x05, 0xf4, 0xb3, 0x04, 0xa7, 0x52, 0xa7, 0x1b,
	0x74, 0x31, 0xe6, 0x30, 0x73, 0xcc, 0x92, 0x2f, 0xf5, 0xd5, 0x13, 0xb8, 0x5e, 0x65, 0xb8, 0x54,
	0xf4, 0xd2, 0x80, 0xd9, 0xc1, 0xe7, 0x29, 0x96, 0xb0, 0xc9, 0xf1, 0x24, 0x9a, 0xb0, 0x19, 0xa3,
	0x95, 0xac, 0xe4, 0xa9, 0xc4, 0x13, 0x16, 0xad, 0x0d, 0x9e, 0x1d, 0xc8, 0x84, 0x71, 0x31, 0x28,
	0xa0, 0x4a, 0xe8, 0x22, 0x3e, 0x95, 0xc8, 0x0b, 0x29, 0x2b, 0xc2, 0xe7, 0x0a, 0xf3, 0xb9, 0xa4,
	0x2c, 0x66, 0x5c, 0x1f, 0xdb, 0xb1, 0x29, 0xaa, 0xc1, 0x64, 0xa4, 0x7b, 0x47, 0x67, 0x7a, 0x6b,
	0x5f, 0xd8, 0x77, 0xcb, 0x4b, 0x19, 0xab, 0xc2, 0xe1, 0x09, 0x64, 0x00, 0xea, 0xed, 0x92, 0xd1,
	0x4a, 0x66, 0x45, 0x8b, 0xd8, 0xbe, 0x90, 0xaf, 0xd4, 0x75, 0xf1, 0x31, 0x3b, 0xa4, 0x58, 0xcf,
	0x9a, 0x38, 0xa4, 0xb4, 0x96, 0x3a, 0x71, 0x48, 0xa9, 0x2d, 0x6f, 0x8f, 0x71, 0xd6, 0xec, 0x65,
	0x18, 0x8f, 0xf6, 0xa8, 0x19, 0xc6, 0x63, 0xbd, 0xa2, 0x72, 0x02, 0xdd, 0x86, 0x72, 0xa2, 0x29,
	0x42, 0xcb, 0xa9, 0x1b, 0xa3, 0xc5, 0xec, 0x7c, 0x8e, 0x46, 0x60, 0x79, 0xeb, 0x3d, 0x58, 0x30,
	0xc9, 0x51, 0xf0, 0xca, 0xc6, 0xff, 0x19, 0xdf, 0x9a, 0x8b, 0x3c, 0x82, 0xd7, 0x5b, 0xf6, 0x2d,
	0x5f, 0x78, 0x4b, 0xfa, 0x48, 0xb6, 0x6c, 0x7a, 0xd8, 0xae, 0xaf, 0x9b, 0xe4, 0x48, 0x15, 0x7f,
	0xb2, 0x07, 0x1b, 0xeb, 0x45, 0xb6, 0xf3, 0x95, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x37, 0x16,
	0xa6, 0xd6, 0xdf, 0x17, 0x00, 0x00,
}
